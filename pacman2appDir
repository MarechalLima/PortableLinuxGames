#!/bin/bash
# Author : Ismael BarrosÂ² <ismael@barros2.org>
# License : BSD http://en.wikipedia.org/wiki/BSD_license

pg4l_dir=$(dirname $(readlink -f $0))
. "$pg4l_dir/util.sh"

shopt -s extglob # Enable extended globs

if [ -z "$*" ]; then
	echo "Usage: $0 <package list> [options]"
	echo "  Package list:"
	echo "    <package>: add 'package'"
	echo "    -<package>: ignore 'package'"
	echo "  Options:"
	echo "    --skip-download: Skip package download"
	echo "    --skip-unpack: Skip package unpacking"
	echo "    --skip-bringup: Skip AppDir bringup"
	echo "    --skip-cleanup: Skip AppDir cleanup"
	echo "    --skip-auto-copy-libs: Skip copying dynamic libraries"
	echo "    --here: AppDir is the current directory"
	exit
fi

case $(cat /etc/issue | head -n 1) in
	Arch*)
		find_dependencies_package() { pacman -Si $1 | egrep "Depends On" | grep -v None | cut -d: -f2; }
		find_dependencies_file() { pacman -Qip $1 | egrep "Depends On" | grep -v None | cut -d: -f2; }
		find_version_file() { v=$(pacman -Qip $1 | egrep "Version" | egrep -v None | cut -d: -f2); echo ${v%-*}; }
		file_name_file() { pacman -Qip $1 | egrep "Name" | egrep -v None | cut -d: -f2- | trimp; }
		file_url_file() { pacman -Qip $1 | egrep "URL" | egrep -v None | cut -d: -f2- | trimp; }
		find_package_file() { v=$(pacman -Qip $1 | egrep "Name" | egrep -v None | cut -d: -f2); echo $v | sed -e "s/^ *//"; }
		find_file_for_package() { ls -1t /var/cache/pacman/pkg/$1-?(+([^-])-)+([0-9\.])-+([^.-]).pkg.tar.xz 2>/dev/null| head -n1; }
		uncompress_package_file() { tar -xf $1; }
		download_package() {
			case "$1" in
			aur/*)
				pkg=${1#*/}
				[ $(find_file_for_package "$pkg") ] && { echo "Package $pkg already downloaded"; return; }

				echo "Building $pkg ..."
				mkdir -p /tmp/pacman2AppDir_build/
				pushd /tmp/pacman2AppDir_build/ || exit 1
					yaourt -G "$pkg" || exit 1
					pushd "$pkg" || exit 1
						makepkg -d || exit 1
						f=$(echo ${pkg}*.pkg.tar.xz)
						sudo mv -v "$f" /var/cache/pacman/pkg/ || exit 1
					popd
					rm -rf "$pkg"
				popd
				;;
			*)
				sudo pacman -Swdd --noconfirm "$1"
				;;
			esac
		}
		;;
	Ubuntu* | Debian*)
		find_dependencies_package() { apt-get info $1; }
		find_dependencies_file() { dpkg info $1; }
		find_version_file() { v=$(pacman -Qip $1 | egrep "Version" | grep -v None | cut -d: -f2); echo ${v%-*}; }
		find_package_file() { v=$(pacman -Qip $1 | egrep "Name" | egrep -v None | cut -d: -f2); echo $v | sed -e "s/^ *//"; }
		find_file_for_package() { ls -1t /var/cache/apt/archives/$1-+([^-])-+([0-9])-+([^.]).deb 2>/dev/null| head -n1; }
		uncompress_package_file() { dpkg-deb -x $1; }
		download_package() { sudo apt-get -y --force-yes --download-only install "$1"; }
		;;
	*)
		echo "Distro not supported"
		exit 1
		;;
esac

DOWNLOAD=1
UNPACK=1
CLEANUP=1
BRINGUP=1

CREATE_APPDIR=1
AUTOCOPYLIBS=1



MainPackage=
MainPackageFile=
MainPackageExec=
MainPackageVersion=
MainPackageURL=
Suffix=-archlinux

declare -a pkgs=()
declare -a files=()
declare -a ignore=("hicolor-icon-theme" "libgl")


# Recolect list of packages
for i in $@; do
	case $i in
		--skip-download) DOWNLOAD=; shift ;;
		--skip-unpack) UNPACK=; shift ;;
		--skip-cleanup) CLEANUP=; shift ;;
		--skip-bringup) BRINGUP=; shift ;;
		--skip-auto-copy-libs) AUTOCOPYLIBS=; shift ;;

		--here) CREATE_APPDIR=; shift ;;

		-*)
			ignore+=("${i#*-}")
			;;
		*)
			if [ -f "$i" ]; then
				# Argument is a file
				files+=("$(readlink -f "$i")")
				for dep in $(find_dependencies_file $i); do
					pkgs+=("$dep")
				done

			else
				# Argument is the name of a package
				pkgs+=("$i")
				for dep in $(find_dependencies_package $i); do
					pkgs+=("$dep")
				done
			fi

			;;
	esac
done

# Download and unpack packages
[ "$pkgs" -o "$files" ] || {
	echo "Nothing to do";
	exit 1;
}

[ "$files" ] && {
	echo "These files will be included:"
	for i in $files; do
		echo "  $i"
	done
}


if [ "$pkgs" ]; then
	pkgs+=("xdg-utils")

	# Automatically substitute virtual package libjpeg with a real package
	pkgs=(${pkgs[@]/libjpeg/libjpeg-turbo})

	for ign in ${ignore[@]}; do
		echo "Ignoring $ign ..."
		pkgs=(${pkgs[@]/#$ign/})
	done

	# Remove version numbers
	for pkg in ${pkgs[@]}; do
		pkgs=(${pkgs[@]/#$pkg/${pkg%%[<>=]*}})
	done

	echo "These packages will be included:"

	for i in ${pkgs[@]}; do
		echo "  $i"
	done
fi


if [ "$DOWNLOAD" ]; then
	# Make sure all packages are downloaded
	for pkg in ${pkgs[@]}; do
		download_package "$pkg" || exit
	done
else
	echo "Skipping download"
fi

# Find the file corresponding with each package
for i in ${pkgs[@]}; do
	pkg=${i#*/}
	file=$(find_file_for_package $pkg)

	if [ -f "$file" ]; then
		files+=" $file"
	else
	       	echo "!! Could not find file for package '$pkg'"
		exit 1
	fi
done

[ "$files" ] || {
	echo "!! No files found";
	exit 1;
}

for i in $files; do
	if [ ! "$MainPackageVersion" ]; then
		MainPackage=$(file_name_file $i)
		MainPackageFile=$(basename $i)
		MainPackageVersion=$(find_version_file $i)
		MainPackageURL=$(file_url_file $i)
		echo "Assuming main package is $MainPackageFile with version $MainPackageVersion"

		if [ "$CREATE_APPDIR" ]; then
			package_name=$(find_package_file $i)
			appDir_path=$PWD/${package_name}.AppDir
			echo "Using AppDir $appDir_path ..."
			mkdir -pv "$appDir_path" || exit 1
			cd "$appDir_path" || exit 1
		fi
	fi
done

if [ "$UNPACK" ]; then
	for i in $files; do
		echo "Uncompressing $i..."
		uncompress_package_file $i || exit 1
	done
else
	echo "Skipping unpack"
fi


[ "$BRINGUP" ] && {
	for i in $(ls -1 usr/share/applications/*.desktop 2>/dev/null); do
		PackageName=$(egrep Name $i | head -n1 | cut -d= -f2)
		PackageExec=$(egrep Exec $i | head -n1 | cut -d= -f2)
		PackageIcon=$(egrep Icon $i | head -n1 | cut -d= -f2)

		echo "Found .desktop file '$PackageName' ($PackageExec)"

		[ "$MainPackageExec" ] || {
			echo "  Using it as main program"
			MainPackageExec=$(basename $PackageExec)

			IconFile="./$PackageIcon"
			[ -f "$IconFile" ] || IconFile=usr/share/pixmaps/$PackageIcon
			[ -f "$IconFile" ] || IconFile=usr/share/icons/$PackageIcon
			[ -f "$IconFile" ] || IconFile=$(ls -1 usr/share/pixmaps/${PackageIcon}.png 2>/dev/null | head -n1)
			[ -f "$IconFile" ] || IconFile=$(ls -1 usr/share/icons/${PackageIcon}.png 2>/dev/null | head -n1)
			[ -f "$IconFile" ] || IconFile=$(ls -1 usr/share/pixmaps/${PackageIcon}.* 2>/dev/null | head -n1)
			[ -f "$IconFile" ] || IconFile=$(ls -1 usr/share/icons/${PackageIcon}.* 2>/dev/null | head -n1)

			if [ -f "$IconFile" ]; then
				echo "Using icon on $IconFile"
				convert -resize 48x "$IconFile" AppRun.png
				[ -f "AppRun-0.png" ] && {
					mv -v AppRun-0.png AppRun.png
					rm -v AppRun-?.png
				}
				optipng AppRun.png 2>/dev/null
			else
				echo "! Icon $PackageIcon not found" >&2
				echo "usr/share/pixmaps:" >&2
				find usr/share/pixmaps >&2
			fi
		}

		[ -f "./$PackageExec" ] && {
			echo "Patching absolute paths in ./$PackageExec"
			"$pg4l_dir/patchAbsolutePaths" "./$PackageExec"
		}

		[ -f AppRun.desktop ] || {
			[ "$MainPackageVersion" ] || {
				"! Main package version not found, using _VERSION_" >&2
				MainPackageVersion=_VERSION_
			}
			echo "Creating AppRun.desktop from '$PackageName $MainPackageVersion' ($i, Exec=$PackageExec)..."
			cp "$pg4l_dir/AppRun.desktop" .

			desktopFile_setParameter "AppRun.desktop" "Name" "$PackageName $MainPackageVersion-r1$Suffix"
			desktopFile_setParameter "AppRun.desktop" "X-AppImage-Title" "$PackageName"
			desktopFile_setParameter "AppRun.desktop" "X-AppImage-Version" "$MainPackageVersion"
			desktopFile_setParameter "AppRun.desktop" "X-AppImage-Release" "1"
			desktopFile_setParameter "AppRun.desktop" "X-AppImage-URL" "$MainPackageURL"
			desktopFile_setParameter "AppRun.desktop" "X-AppImage-ID" "$MainPackage"
			desktopFile_setParameter "AppRun.desktop" "X-AppImage-SourcePackage" "$MainPackageFile"
		}

	done

	[ -f AppRun ] || {
		[ "$MainPackageExec" ] || {
			echo "! Main package executable not found, using _BINARY_"
			MainPackageExec="_BINARY_"
		}

		echo "Creating AppRun with Exec='${MainPackageExec}'..."
		cp "$pg4l_dir/AppRun" .
		
		sed -e"s/_BINARY_/$MainPackageExec/g" AppRun -i
		chmod +x AppRun
	}
	cp "$pg4l_dir/util.sh" . || exit 1

	# Force applications to use usr instead of opt
	if [ -d opt ]; then
		mkdir -p usr/
		mv -v opt/* usr/
		rmdir opt
	fi


	rm -vf usr/bin/{ar,as,nm,gprof,elfedit,ld,ld.*,objcopy,objdump,makehrtf,c++filt,addr2line,curl,*-config,*-info,png2pnm,pnm2png,ranlib,readelf,size,strings,strip,wxrc*,xml2-config,xmlcatalog,xmllint,glewinfo,visualinfo,cjpeg,desktop-file-*,djpeg,jpegtran,lua,luac,rdjpgcom,update-desktop-database,wrjpgcom}

	# Actually, patch'em all, for good measure.
	"$pg4l_dir/patchAbsolutePaths" usr/bin/*

	if [ $AUTOCOPYLIBS ]; then
		echo "Copying missling libraries..."
		chmod +x usr/lib/*.so*
		"$pg4l_dir/copyMissingLibraries"
	fi
} || {
	echo "Skipping bringup"
}


if [ "$CLEANUP" ]; then
	rubbish="usr/include usr/share/applications usr/share/desktop-directories usr/share/pixmaps usr/share/icons usr/share/man usr/share/info usr/share/doc usr/share/mime usr/share/aclocal usr/lib/pkgconfig usr/lib/*.a .INSTALL .PKGINFO"
	for i in $rubbish; do
		[ -e "$i" ] && {
			echo "Deleting $i..."
			rm -rf "$i"
		}
	done
else
	echo "Skipping cleanup"
fi
